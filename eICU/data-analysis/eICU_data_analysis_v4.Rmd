---
title: Oxygen project using eICU data
author: Willem van den Boom
date: October 6, 2018
output:
  html_document: default
editor_options:
  chunk_output_type: inline
---

```{r, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r setup, results='hide'}
if(!require(bigrquery)) {
  install.packages("bigrquery")
  library("bigrquery")
}

# Project ID from Google Cloud
project_id <- "oxygenators-209612"
options(httr_oauth_cache=FALSE)

# Wrapper for running BigQuery queries.
run_query <- function(query){
    data <- query_exec(query, project=project_id, use_legacy_sql = FALSE, max_pages = Inf)
    return(data)
}

# Library for fitting generalized additive models (GAMs)
library(mgcv)
if(!require(mgcv)) {
  install.packages("mgcv")
  library("mgcv")
}
```


# Read in data from eICU

```{r eval=FALSE}
patient <- run_query('
SELECT * FROM eicu.final_patient_results
')

O2measurement <- run_query('
SELECT * FROM eicu.final_measurement_results
')
```

```{r include=FALSE, eval=FALSE}
save(patient, O2measurement, file = "RData/eICU_data_analysis_v4_checkpoint1.RData")
```

```{r loadData, include=FALSE, eval=TRUE}
# Since Google authentication cannot happen when knitting an R Markdown file,
# I load the results from BigQuery from an RData file.
load("RData/eICU_data_analysis_v4_checkpoint1.RData")
```


# Data preprocessing

## Gender

Transform gender to a factor rather than string
Set genders that are neither male nor female as missing, effectively excluding these from the analysis
```{r}
if(is.character(patient$gender)) patient$gender_string <- patient$gender
summary(as.factor(patient$gender_string))

patient$gender <- NA
patient$gender[patient$gender_string == "Female"] = "F"
patient$gender[patient$gender_string == "Male"] = "M"

patient$gender = as.factor(patient$gender)
```


## ICU type

Consolidate the various ICU types such that only general, cardiac, and neuro ICU remain.


### From Slack

*Mornin Feng*
The followings are my suggestions:
1/ Just exclude Neuro ICUS
2/ Merge  “Cardiac ICU”
“CCU-CTICU”: Coronary Care Unit / Cardiothoracic ICU
“CTICU”: Cardiothoracic ICU
as CCUs, BUT keep “CSICU”: Cardiac Surgery ICU separately as CSICU
3/ MICU and SICU should not be merged
4/ Med-Surg ICU, KC See what do you think? (edited)


*KC See*
I largely agree with Mornin. The Neuro ICU is unclear what it is - Medical Neuro vs Neurosurgical. For CSICU, I think it is like CTICU. Can we do analysis with and without it, and see if there is a difference? MICU, MSICU, and SICU should be separate. Then if all shows similar results, we can pool everything too

```{r}
patient$unit_type = as.factor(patient$unittype)

#levels(patient$unit_type)[levels(patient$unit_type) %in% c("Med-Surg ICU", "MICU", "SICU")] = "General ICU"
levels(patient$unit_type)[levels(patient$unit_type) %in% c("CCU-CTICU", "CSICU", "CTICU")] = "Cardiac ICU"
```


## Determine first stay

We use `hospitalDischargeYear` and `unit_stay_number` to determine whether an ICU stay was a patient's first.

Note that `unit_stay_number` [does not always start at 1](https://github.com/MIT-LCP/eicu-code/issues/16).
```{r firstStay}
patient$first_stay = NA

for(i in 1:max(patient$unit_stay_number)) {
  tmp_table = table(patient$patient_ID[
    patient$unit_stay_number <= i
    & is.na(patient$first_stay)
  ])
  
  # An ICU stay that is a patient's only one with `unit_stay_number` <= i
  # must be a first stay.
  tmp_index <- patient$patient_ID %in% names(tmp_table)[tmp_table == 1]
  
  patient$first_stay[
     tmp_index
  ] <- FALSE
  
  patient$first_stay[
    tmp_index
    & patient$unit_stay_number <= i
  ] <- TRUE
}


# `hospitalDischargeYear` only takes the values 2014 and 2015
unique(patient$hospitalDischargeYear)

# The remaning NAs in first_stay can only be resolved if a patient
# has only 1 hospital stay with a discharge in 2014
tmp_IDs <- unique(patient$patient_ID[
  is.na(patient$first_stay)
  & patient$hospitalDischargeYear == 2014
])

for(id in tmp_IDs) {
  tmp_index <- which(
    patient$patient_ID == id &
    patient$hospitalDischargeYear == 2014
  )
  
  if(length(tmp_index) == 1) {
    patient$first_stay[patient$patient_ID == id] <- FALSE
    patient$first_stay[tmp_index] <- TRUE
  }
}

rm(tmp_table, tmp_index, tmp_IDs, i, id)

summary(patient$first_stay)
length(unique(patient$patient_ID))
length(unique(patient$patient_ID[is.na(patient$first_stay)]))
```




# Ventilation times

We determine the ventilation times based on a variety of data tables.
We do not use `respiratorycare` since it time stamps [are not recorded correctly](https://github.com/MIT-LCP/eicu-code/issues/49).

In `nursecharting`, we look at the presence of a positive oxygen flow or oxygen admin devices that indicate oxygen therapy.
We are only interested in positive oxygen flows. Also, we ignore what happens more than an hour in advance of ICU admission.
```{r loadO2flowData, eval=FALSE}
vent_times <- run_query("
SELECT DISTINCT
    patientunitstayid as icustay_id,
		nursingChartOffset as time
		FROM `oxygenators-209612.eicu.nursecharting`
    WHERE (  ( nursingchartcelltypevallabel = 'O2 L/%'
    AND SAFE_CAST(nursingChartValue AS INT64) > 0
    AND SAFE_CAST(nursingChartValue AS INT64) <= 100
    ) OR (
			nursingchartcelltypevallabel = 'O2 Admin Device'
		AND LOWER(nursingchartvalue) IN (
			-- This list is not exhaustive. It is a classification by Willem of the most common O2 devices that indicate oxygen therapy. We should probably check it with KC See
			'ventilator',
'vent',
'trach collar',
'ett oral',
'nasal cannula',
'bipap/cpap',
'trach collar',
'nc',
'venturi mask',
'non-rebreather',
'cool aerosol mask',
'bipap',
'oxymizer',
'hfnc',
'cpap',
'oximizer',
'high flow',
'oxymask',
'niv', -- noninvasive ventilation
'face tent',
'vented',
'hi flow',
'hiflow'
		) ) )
    AND nursingChartOffset > -60
")
```

`respiratorycharting.respchartvaluelabel` sometimes indicates ventilation.
```{r load_resp_chart, eval=FALSE}
vent_times <- rbind(vent_times, run_query("
SELECT DISTINCT patientunitstayid as icustay_id,
					respchartoffset as time
   FROM `oxygenators-209612.eicu.respiratorycharting`
  WHERE respchartoffset >= 0 AND 
( LOWER(respchartvaluelabel) LIKE '%ventilator%'
     OR LOWER(respchartvaluelabel) LIKE '%vent%'
     OR LOWER(respchartvaluelabel) LIKE '%bipap%'
     OR LOWER(respchartvaluelabel) LIKE '%840%'
     OR LOWER(respchartvaluelabel) LIKE '%cpap%'
     OR LOWER(respchartvaluelabel) LIKE '%drager%'
     OR LOWER(respchartvaluelabel) LIKE 'mv%'
     OR LOWER(respchartvaluelabel) LIKE '%servo%'
     OR LOWER(respchartvaluelabel) LIKE '%peep%' )
"))
```

`treatment.treatmentstring` sometimes indicates ventilation.
```{r load_treatment, eval=FALSE}
treatment <- run_query("
SELECT DISTINCT patientunitstayid as icustay_id,
					treatmentoffset as time,
          activeUponDischarge
FROM `oxygenators-209612.eicu.treatment`
WHERE treatmentstring IN ('pulmonary|ventilation and oxygenation|mechanical ventilation', 'pulmonary|ventilation and oxygenation|tracheal suctioning', 'pulmonary|ventilation and oxygenation|ventilator weaning', 'pulmonary|ventilation and oxygenation|mechanical ventilation|assist controlled', 'pulmonary|radiologic procedures / bronchoscopy|endotracheal tube', 'pulmonary|ventilation and oxygenation|oxygen therapy (> 60%)', 'pulmonary|ventilation and oxygenation|mechanical ventilation|tidal volume 6-10 ml/kg', 'pulmonary|ventilation and oxygenation|mechanical ventilation|volume controlled', 'surgery|pulmonary therapies|mechanical ventilation', 'pulmonary|surgery / incision and drainage of thorax|tracheostomy', 'pulmonary|ventilation and oxygenation|mechanical ventilation|synchronized intermittent', 'pulmonary|surgery / incision and drainage of thorax|tracheostomy|performed during current admission for ventilatory support', 'pulmonary|ventilation and oxygenation|ventilator weaning|active', 'pulmonary|ventilation and oxygenation|mechanical ventilation|pressure controlled', 'pulmonary|ventilation and oxygenation|mechanical ventilation|pressure support', 'pulmonary|ventilation and oxygenation|ventilator weaning|slow', 'surgery|pulmonary therapies|ventilator weaning', 'surgery|pulmonary therapies|tracheal suctioning', 'pulmonary|radiologic procedures / bronchoscopy|reintubation', 'pulmonary|ventilation and oxygenation|lung recruitment maneuver', 'pulmonary|surgery / incision and drainage of thorax|tracheostomy|planned', 'surgery|pulmonary therapies|ventilator weaning|rapid', 'pulmonary|ventilation and oxygenation|prone position', 'pulmonary|surgery / incision and drainage of thorax|tracheostomy|conventional', 'pulmonary|ventilation and oxygenation|mechanical ventilation|permissive hypercapnea', 'surgery|pulmonary therapies|mechanical ventilation|synchronized intermittent', 'pulmonary|medications|neuromuscular blocking agent', 'surgery|pulmonary therapies|mechanical ventilation|assist controlled', 'pulmonary|ventilation and oxygenation|mechanical ventilation|volume assured', 'surgery|pulmonary therapies|mechanical ventilation|tidal volume 6-10 ml/kg', 'surgery|pulmonary therapies|mechanical ventilation|pressure support', 'pulmonary|ventilation and oxygenation|non-invasive ventilation', 'pulmonary|ventilation and oxygenation|non-invasive ventilation|face mask', 'pulmonary|ventilation and oxygenation|non-invasive ventilation|nasal mask', 'pulmonary|ventilation and oxygenation|mechanical ventilation|non-invasive ventilation', 'pulmonary|ventilation and oxygenation|mechanical ventilation|non-invasive ventilation|face mask', 'surgery|pulmonary therapies|non-invasive ventilation', 'surgery|pulmonary therapies|non-invasive ventilation|face mask', 'pulmonary|ventilation and oxygenation|mechanical ventilation|non-invasive ventilation|nasal mask', 'surgery|pulmonary therapies|non-invasive ventilation|nasal mask', 'surgery|pulmonary therapies|mechanical ventilation|non-invasive ventilation', 'surgery|pulmonary therapies|mechanical ventilation|non-invasive ventilation|face mask')
")
```

```{r include=FALSE, eval=FALSE}
save.image(file = "RData/eICU_data_analysis_v4_checkpoint_vent.RData")
```

Oxygen flows and respiratorycharting entries are usually recorded every 60 minutes and oxygen administration devices mostly in at most 2 hour intervals but we allow for gaps of up to 24*60 minutes.
Treatment is recorded irregularly but mostly more often than every day (24*60 minutes). So, we also allow gaps there.
```{r determineVentilation, eval=FALSE}
tmp_IDs <- unique(patient$patientunitstayid[patient$first_stay & !is.na(patient$first_stay)])

# We only keep entries in `vent_times` and `treatment` that appear in tmp_IDs for computational efficiency.
vent_times <- vent_times[vent_times$icustay_id %in% tmp_IDs,]
treatment <- treatment[treatment$icustay_id %in% tmp_IDs,]

tmp_IDs <- unique(vent_times$icustay_id, treatment$icustay_id)
n <- length(tmp_IDs)

patient$vent_start <- NA_integer_
patient$vent_end <- NA_integer_

pb <- txtProgressBar(max = n, style = 3)
for(i in 1:n) {
  id <- tmp_IDs[i]
  patient_ind <- which(patient$patientunitstayid == id)
  
  tmp_treatment <- treatment[treatment$icustay_id == id, -1]
  times <- sort(c(vent_times$time[vent_times$icustay_id == id], tmp_treatment$time))
  patient$vent_start[patient_ind] <- times[1]
  
  n_times <- length(times)
  
  breaks <- diff(times) > 60*24
  
  if(!any(breaks)) {
    patient$vent_end[patient_ind] <- times[n_times]
  } else {
    patient$vent_end[patient_ind] <- times[which(breaks)[1]]
  }
  
  if(any(tmp_treatment$activeUponDischarge)) {
    last_treatment_time <- min(tmp_treatment$time[which(tmp_treatment$activeUponDischarge)])
    if(last_treatment_time <= patient$vent_end[patient_ind])   {
      patient$vent_end[patient_ind] <- max(
        # The ventilation end time cannot be later/longer than the ICU length of stay
        last_treatment_time,
        24*60*patient$icu_length_of_stay[patient_ind]
      )
    }
  }
  
  setTxtProgressBar(pb, i)
}
close(pb)

rm(tmp_IDs, n, id, times, n_times, breaks, i, pb, vent_times, treatment, last_treatment_time)

# End time is currently a charting time
# Since these are usually recorded hourly, ventilation is actually longer
patient$vent_end <- patient$vent_end + 60
```


```{r include=FALSE, eval=FALSE}
save.image(file = "RData/eICU_data_analysis_v4_checkpoint_vent2.RData")
```

```{r include=FALSE, eval=TRUE}
load(file = "RData/eICU_data_analysis_v4_checkpoint_vent2.RData")
```

```{r}
mean(is.na(patient$vent_start))
mean(is.na(patient$vent_end))
summary(patient$vent_end - patient$vent_start)
mean(patient$vent_end - patient$vent_start >= 60*24, na.rm = TRUE)
mean(patient$vent_end - patient$vent_start >= 60*24*2, na.rm = TRUE)
mean(patient$vent_end - patient$vent_start >= 60*24*3, na.rm = TRUE)
```



# Oxygen measurements

We remove oxygen measurements that are outside of the range [10, 100]
```{r}
O2measurement <- O2measurement[O2measurement$spO2_Value <= 100 & O2measurement$spO2_Value >= 10,]
```

Count the number of oxygen measurements per first ventilation of ICU stay
Since we only need these counts for the first ICU stay, we constrain ourselves to this subset for speed.
We only count measurements that happen during the first ventilation, and we are only interested in ventilations of at least 48 hours.
```{r countOxygen, include=TRUE, eval=FALSE}
nOxy_limit <- 24

tmp <- unique(O2measurement$icustay_id)
tmp <- tmp[!(tmp %in% patient$icustay_id[patient$first_stay & patient$vent_end - patient$vent_start >= 60*24*2])]
tmp <- table(O2measurement$icustay_id, exclude = tmp)

patient$nOxy <- as.numeric(tmp[match(patient$icustay_id, names(tmp))])
rm(tmp)

# ICU stays that do not have any measurements are currently NA and should be 0.
patient$nOxy[which(is.na(patient$nOxy) & patient$vent_end - patient$vent_start >= 60*24*2)] <- 0


# We've counted all oxygen measurements.
# We should only be counting the measurements that happen during ventilation
tmp_IDs <- patient$icustay_id[which(patient$vent_end - patient$vent_start >= 60*24*2 & patient$nOxy >= nOxy_limit)]
n <- length(tmp_IDs)

# Delete O2measurements that belong to patients that won't be in the selected subset
O2measurement <- O2measurement[O2measurement$icustay_id %in% tmp_IDs,]

index <- match(tmp_IDs, patient$icustay_id)

pb <- txtProgressBar(max = n, style = 3)
for(i in 1:n) {
  ind <- index[i]
  
  patient$nOxy[ind] <- sum(
    O2measurement$icustay_id == tmp_IDs[i]
    & O2measurement$measurement_time >= patient$vent_start[ind]
    & O2measurement$measurement_time <= patient$vent_end[ind]
  )
  
  setTxtProgressBar(pb, i)
}
close(pb)
rm(pb, i, index, tmp_IDs, n, ind)
```

```{r include=FALSE, eval=FALSE}
save.image(file = "RData/eICU_data_analysis_v4_checkpoint_vent2_2.RData")
```

```{r include=FALSE, eval=TRUE}
load(file = "RData/eICU_data_analysis_v4_checkpoint_vent2_2.RData")
```

```{r}
mean(patient$nOxy[which(patient$vent_end - patient$vent_start >= 60*24*2)] >= nOxy_limit)
```


# Subset selection

The following code selects cases of interest while also providing the info required for a flow diagram: That is, how many patients did not meet the inclusion criteria.

```{r}
cat("Total number of ICU stays:", nrow(patient))

# We only keep first stays with at least 48 hours of ventilation
tmp <- which(patient$first_stay)
cat("\nNumber of first stays:", length(tmp))
cat("\nNumber of patients for whom we couldn't determine first stays:", length(unique(patient$patient_ID[is.na(patient$first_stay)])))
tmp <- which(patient$vent_end - patient$vent_start >= 60*24*2)
cat("\nNumber of first ventilations of at least 48 hours:", length(tmp))
patient_subset <- patient[tmp,]



cat("Number of selected patients so far:", nrow(patient_subset))

# Ages above 89 are recorded as "> 89" in the eICU data
# The current SQL code translates "> 89" to "89" such that we cannot distinguish between 89 and >89.
# As we use age as a confounder, we remove those with age 89.
# We only consider "adults" (age >= 16).
tmp <- patient_subset$age < 16 | patient_subset$age == 89
cat("\nPatients outside age range:", sum(tmp, na.rm = TRUE))
cat("\nPatients with missing age:", sum(is.na(tmp)))
tmp[is.na(tmp)] <- TRUE

# `delete` records which cases to delete from patient
delete <- tmp

# Delete those whose gender is unknown or other
tmp <- is.na(patient_subset$gender)
cat("\nPatients with missing or 'other' gender:", sum(tmp))
delete <- delete | tmp

cat("\nPatients selected so far:", sum(!delete))


# Delete those with fewer than 24 oxygen measurements
tmp <- patient_subset$nOxy < nOxy_limit
cat("\nPatients with too few measurements:", sum(tmp), "out of", nrow(patient_subset))
delete <- delete | tmp


patient_subset <- patient_subset[!delete,]
cat("\nPatients selected:", nrow(patient_subset))

rm(delete)
```


```{r, include = FALSE, eval = FALSE}
## We only keep hospitals with at least 100 cases
# cat("\n Number of hospitals in current subset:", length(unique(patient_subset$hospital_id)))
# 
# tmp <- table(patient_subset$hospital_id)
# cat("\n Number of hospitals with at least 100 patients:", sum(tmp >= 100))
# 
# delete <- patient_subset$hospital_id %in% as.numeric(names(tmp[tmp < 100]))
# patient_subset <- patient_subset[!delete,]
# patient_subset$hospital_id = as.factor(patient_subset$hospital_id)
# 
# cat("\n Number of patients in selected subset:", nrow(patient_subset))
# 
# rm(tmp, delete)
```



## Cleaning

```{r}
patient_subset$patientunitstayid <- NULL # Duplicates icustay_id

# Delete O2measurements that belong to patients not in the selected subset
O2measurement <- O2measurement[O2measurement$icustay_id %in% patient_subset$icustay_id,]

# Cases with no diagnoses from ICD-9 codes have all diagnoses as "NA"
# These should be FALSE.
for(j in which(grepl("has_", names(patient_subset)))) {
  patient_subset[is.na(patient_subset[,j]), j] <- FALSE
}
rm(j)
```


## Demographics

Let us compare the demographics before and after the subset selection.

```{r}
# Variables of which we like summaries
tmp <- c('age', 'gender', 'unit_type', 'nOxy', 'mortality_in_ICU')

cat("Mortality in 'patient':", sum(patient$mortality_in_ICU), "\n")
summary(patient[patient$age >= 16,tmp])

cat("Mortality in 'patient_subset':", sum(patient_subset$mortality_in_ICU), "\n")
summary(patient_subset[,tmp])
```


```{r include=FALSE, eval=FALSE}
save.image(file = "RData/eICU_data_analysis_v4_checkpoint_vent3.RData")
```


# Compute summaries of oxygen measurements

We compute the median oxygen level and the proportion of measurements within 94% to 97% oxygen saturation.
We do this after subset selection as it is much faster to compute these only for the subset of interest.

We currently ignore the time aspect of the measurements. However, one should probably take into account that certain measurements are less spread out than others.

```{r oxygenSummaries, eval=FALSE}
patient_subset$median <- NA
patient_subset$prop <- NA
n <- nrow(patient_subset)
pb <- txtProgressBar(max = n, style = 3)

for(i in 1:n) {
  tmp <- O2measurement$spO2_Value[
    O2measurement$icustay_id == patient_subset$icustay_id[i]
    & O2measurement$measurement_time >= patient_subset$vent_start[i]
    & O2measurement$measurement_time <= patient_subset$vent_end[i]
  ]
  
  patient_subset$median[i] <- median(tmp)
  patient_subset$prop[i] <- mean(tmp >= 94 & tmp <= 97)
  
  setTxtProgressBar(pb, i)
}
close(pb)
rm(i,tmp,pb,O2measurement)

summary(patient_subset$median)
summary(patient_subset$prop)
```

```{r include=FALSE, eval=FALSE}
save.image("RData/eICU_data_analysis_v4_checkpoint2.RData")
```

```{r loadProcessedData, include=FALSE, eval=TRUE}
# Since computing the oxygen summaries takes a long time,
# I load the results from an RData file.
load("RData/eICU_data_analysis_v4_checkpoint2.RData")
```


```{r include=FALSE, eval=FALSE}
# Upload patient_subset to BigQuery to make it available outside of R

# BigQuery does not seem to always know how to deal with NAs.
# We therefore get rid of some of them before uploading.
patient_subset_temp <- patient_subset
patient_subset_temp$max_fiO2[is.na(patient_subset_temp$max_fiO2)] <- -99.9

ds <- bq_table(project = project_id, dataset = "eicu", table = "patient_cohort")

if(bq_table_exists(ds)) bq_table_delete(ds)

bq_table_upload(
  x = ds,
  values = patient_subset_temp,
  quiet = FALSE
)

rm(ds, patient_subset_temp)
```


Plot some basic comparison of the two outcome groups.
```{r}
boxplot(patient_subset$median ~ patient_subset$mortality_in_ICU)
boxplot(patient_subset$prop ~ patient_subset$mortality_in_ICU)
```


# Model fitting

## Median of measurements

We fit a generalized additive model (GAM) to check for the effect of the median oxygen saturation. GAMs are regression models that allow for nonlinear effects of the predictors.
We add gender and age as predictors to control for them. We also control for hospital but since there are so many hospitals, we add it as a random effect.

```{r}
logistic <- function(x) 1/(1+exp(-x))
```

```{r gamfitMed}
gamfitMed <- gam(mortality_in_ICU ~ s(median)+gender+s(age), data = patient_subset, family = binomial)#gamm(mortality_in_ICU ~ s(median)+gender+s(age), data = patient_subset, family = binomial, random = list(hospital_id = ~ 1))$gam
summary(gamfitMed)

xRange = c(92, 100)
yRange = c(0, .2)

xlab <- "Median oxygen saturation (SpO2)"
ylab <- "Probability of ICU mortality" 

xName <- "median"

main <- "Median of measurements"

# Color for dotted line
colD <- "Black"

    plot(1, type = 'n', xlim = xRange, ylim = yRange,
         ylab = ylab,
         xlab = xlab, main = main, yaxs = 'i', xaxs = 'i', yaxt = 'n', xaxt = 'n')
    
    att <- pretty(yRange)
if(!isTRUE(all.equal(att, round(att, digits = 2)))) {
  axis(2, at = att, lab = paste0(sprintf('%.1f', att*100), '%'), las = TRUE)
} else axis(2, at = att, lab = paste0(att*100, '%'), las = TRUE)
    
    att <- pretty(xRange)
    axis(1, at = att, lab = paste0(att, '%'), las = TRUE)

    
    eval(parse(text = paste(c('predictionsPlusCI <- predict(gamfitMed, newdata = data.frame(',
                              xName, ' = gamfitMed$model$', xName, ", gender = 'F', age = median(gamfitMed$model$age), hospital_id = 264), type = 'link', se.fit = T)"), collapse = "")))

  
  # We have to use the data on which GAM was fit for confidence region as the GAM does not provide standard errors for 'new' input
  eval(parse(text = paste0('xx <- gamfitMed$model$', xName)))
  ord.index <- order(xx)
  xx <- xx[ord.index]
  
  if(gamfitMed$family$link == 'logit') {
    lcl <- logistic(predictionsPlusCI$fit[ord.index] - 1.96*predictionsPlusCI$se.fit[ord.index])
    ucl <- logistic(predictionsPlusCI$fit[ord.index] + 1.96*predictionsPlusCI$se.fit[ord.index])
    
    lines(x = xx, y = lcl, lty = 2, lwd = 2, col = colD)
    lines(x = xx, y = ucl, lty = 2, lwd = 2, col = colD)
    lines(xx, logistic(predictionsPlusCI$fit[ord.index]), lwd = 3)
  } else {
    lcl <- predictionsPlusCI$fit[ord.index] - 1.96*predictionsPlusCI$se.fit[ord.index]
    ucl <- predictionsPlusCI$fit[ord.index] + 1.96*predictionsPlusCI$se.fit[ord.index]
    
    lines(x = xx, y = lcl, lty = 2, lwd = 2)
    lines(x = xx, y = ucl, lty = 2, lwd = 2)
    lines(xx, predictionsPlusCI$fit[ord.index], lwd = 3)
  }
```


## Proportion of measurements within range

We now fit a GAM with the proportion of measurements within a range instead of the median of the measurements.

```{r gamfitProp}
gamfitProp <- gam(mortality_in_ICU ~ s(prop)+gender+s(age), data = patient_subset, family = binomial)#gamm(mortality_in_ICU ~ s(prop)+gender+s(age), data = patient_subset, family = binomial, random = list(hospital_id = ~ 1))$gam
summary(gamfitProp)

logistic <- function(x) 1/(1+exp(-x))
xRange = c(0, max(patient_subset$prop, na.rm= TRUE))
yRange = c(0, .2)

xlab <- "Proportion of time with an SpO2 within 94 to 97"
ylab <- "Probability of ICU mortality" 

xName <- "prop"

main <- "Effect of treatment regime"

    plot(1, type = 'n', xlim = xRange, ylim = yRange,
         ylab = ylab,
         xlab = xlab, main = main, yaxs = 'i', xaxs = 'i', yaxt = 'n', xaxt = 'n')
    
    att <- pretty(yRange)
if(!isTRUE(all.equal(att, round(att, digits = 2)))) {
  axis(2, at = att, lab = paste0(sprintf('%.1f', att*100), '%'), las = TRUE)
} else axis(2, at = att, lab = paste0(att*100, '%'), las = TRUE)
    
    att <- pretty(xRange)
    axis(1, at = att, lab = paste0(att*100, '%'), las = TRUE)

    
    eval(parse(text = paste(c('predictionsPlusCI <- predict(gamfitProp, newdata = data.frame(',
                              xName, ' = gamfitProp$model$', xName, ", gender = 'F', age = median(gamfitProp$model$age)), type = 'link', se.fit = T)"), collapse = "")))

  
  # We have to use the data on which GAM was fit for confidence region as the GAM does not provide standard errors for 'new' input
  eval(parse(text = paste0('xx <- gamfitProp$model$', xName)))
  ord.index <- order(xx)
  xx <- xx[ord.index]
  
  if(gamfitProp$family$link == 'logit') {
    lcl <- logistic(predictionsPlusCI$fit[ord.index] - 1.96*predictionsPlusCI$se.fit[ord.index])
    ucl <- logistic(predictionsPlusCI$fit[ord.index] + 1.96*predictionsPlusCI$se.fit[ord.index])
    
    lines(x = xx, y = lcl, lty = 2, lwd = 2)
    lines(x = xx, y = ucl, lty = 2, lwd = 2)
    lines(xx, logistic(predictionsPlusCI$fit[ord.index]), lwd = 3)
  } else {
    lcl <- predictionsPlusCI$fit[ord.index] - 1.96*predictionsPlusCI$se.fit[ord.index]
    ucl <- predictionsPlusCI$fit[ord.index] + 1.96*predictionsPlusCI$se.fit[ord.index]
    
    lines(x = xx, y = lcl, lty = 2, lwd = 2)
    lines(x = xx, y = ucl, lty = 2, lwd = 2)
    lines(xx, predictionsPlusCI$fit[ord.index], lwd = 3)
  }
```



## Odds ratios

Based on the model fits, we can estimate odds ratios, including 95% confidence intervals.

```{r results='hide'}
if(!require("oddsratio")) {
  install.packages("oddsratio")
  library(oddsratio)
}
```

```{r}
tmp <- or_gam(data = patient_subset, model = gamfitMed, pred = "median", values = c(96, 100))

cat(
  "The odds ratio of mortality for a median oxygen saturation at 100% versus 96% is ",
  tmp$oddsratio,
  " (95% CI ",
  tmp$`CI_high (97.5%)`,
  " to ",
  tmp$`CI_low (2.5%)`,
  ").",
  sep = ""
)
```

```{r}
tmp <- or_gam(data = patient_subset, model = gamfitProp, pred = "prop", values = c(.8, .4))

cat(
  "The odds ratio of mortality for a proportion of measurements within the range at 40% versus 80% is ",
  tmp$oddsratio,
  " (95% CI ",
  tmp$`CI_low (2.5%)`,
  " to ",
  tmp$`CI_high (97.5%)`,
  ").",
  sep = ""
)
```
